{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WISP This project is developed by Competitive Programming McGill . WISP is a project aimed at creating a fluid and fun experience for members of Compete McGill to learn competitive programming.","title":"Introduction"},{"location":"#wisp","text":"This project is developed by Competitive Programming McGill . WISP is a project aimed at creating a fluid and fun experience for members of Compete McGill to learn competitive programming.","title":"WISP"},{"location":"architecture/","text":"WISP consists of a set of loosly coupled, collaborating services. This structure is what's known as a microservice architecture where each service can be developed, tested, deployed, scaled, and maintained independently from the others. Diagram This is a high-level overview of WISP's architecture: Components Gateway The gateway is responsible for routing traffic to the microservices. Through a set of predefined rules, the gateway analyses the user's request and routes it to the appropriate service. This is also where part of the authorization will occur as, before routing the request, the gateway will forward the user's token to one of our microservices which will in turn check for the appropriate permissions and instruct the gateway to either allow or deny the request. We currently use NGINX for our gateway. Microservices The microservices are simple APIs that handle one or, if absolutely necessary, two resources. They all come equipped with basic CRUD functionality as well as some custom routes that follow REST conventions. While independent from each other in terms of development and deployment, they can still communicate through HTTP (until an event/messaging system is implemented). One thing to note is that service to service communication doesn't go through the gateway and doesn't require authorization or authentication. We use Express for our APIs, Vue for our UI, and GKE for deployment. Database We use a managed MongoDB solution for our database called Atlas . Our instances are deployed and managed on GCP so we don't have to go through maintaining and updating them.","title":"Architecture"},{"location":"architecture/#diagram","text":"This is a high-level overview of WISP's architecture:","title":"Diagram"},{"location":"architecture/#components","text":"","title":"Components"},{"location":"architecture/#gateway","text":"The gateway is responsible for routing traffic to the microservices. Through a set of predefined rules, the gateway analyses the user's request and routes it to the appropriate service. This is also where part of the authorization will occur as, before routing the request, the gateway will forward the user's token to one of our microservices which will in turn check for the appropriate permissions and instruct the gateway to either allow or deny the request. We currently use NGINX for our gateway.","title":"Gateway"},{"location":"architecture/#microservices","text":"The microservices are simple APIs that handle one or, if absolutely necessary, two resources. They all come equipped with basic CRUD functionality as well as some custom routes that follow REST conventions. While independent from each other in terms of development and deployment, they can still communicate through HTTP (until an event/messaging system is implemented). One thing to note is that service to service communication doesn't go through the gateway and doesn't require authorization or authentication. We use Express for our APIs, Vue for our UI, and GKE for deployment.","title":"Microservices"},{"location":"architecture/#database","text":"We use a managed MongoDB solution for our database called Atlas . Our instances are deployed and managed on GCP so we don't have to go through maintaining and updating them.","title":"Database"},{"location":"getting_started/","text":"Getting Started Work in progress :) Check the tab of the specific microservice that you'd like to work with for more information on it.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"Work in progress :) Check the tab of the specific microservice that you'd like to work with for more information on it.","title":"Getting Started"},{"location":"microservices/general/","text":"Project layout src/ # Contains all source code config/ controllers/ database/ interactions/ models/ interfaces/ routes/ util/ validators/ app.ts server.ts docs/ index.md # This documentation page. ... # Other markdown pages, images and other files. test/ unit/ util/ chart/ Dockerfile docker-compose.yaml mkdocs.yml # Configuration for these docs LICENSE nodemon.json package.json package-lock.json swaggerDoc.js tsconfig.json tslint.json For Development Requirements docker docker-compose Running locally The problems microservice does not depend on any other microservice to be running simultaneously. Clone the desired repository (each microservice can be found in this README ). Then navigate locally to the root of the repo and run: npm install npm start see npm start in Available Commands Available Commands The following commands are standardized among API microservices to ensure consistency. All microservice repos use these commands: Command Description npm start spins up a MongoDB instance as well as your API server through docker-compose (see docker-compose.yaml ). Be sure that ports 27017 and 3000 are unused by other services npm run start:local runs a nodemon server that listens for changes in the src directory (requires nodemon and ts-node ) npm run start:prod starts the API server in the production env. Must be run after npm run build (requires node and tsc ) npm run test runs unit tests on new instances of MongoDB and the API (see docker-compose.test.yaml ). Once the tests finish running, both instances stop npm run test:local runs unit tests without docker and MongoDB (requires nyc , mocha , and ts-node ) npm run build builds the API for production and outputs the result in dist/ (requires tsc ) npm run lint lints the src directory according to tslint.json and tsconfig.json","title":"General"},{"location":"microservices/general/#project-layout","text":"src/ # Contains all source code config/ controllers/ database/ interactions/ models/ interfaces/ routes/ util/ validators/ app.ts server.ts docs/ index.md # This documentation page. ... # Other markdown pages, images and other files. test/ unit/ util/ chart/ Dockerfile docker-compose.yaml mkdocs.yml # Configuration for these docs LICENSE nodemon.json package.json package-lock.json swaggerDoc.js tsconfig.json tslint.json","title":"Project layout"},{"location":"microservices/general/#for-development","text":"Requirements docker docker-compose Running locally The problems microservice does not depend on any other microservice to be running simultaneously. Clone the desired repository (each microservice can be found in this README ). Then navigate locally to the root of the repo and run: npm install npm start see npm start in Available Commands","title":"For Development"},{"location":"microservices/general/#available-commands","text":"The following commands are standardized among API microservices to ensure consistency. All microservice repos use these commands: Command Description npm start spins up a MongoDB instance as well as your API server through docker-compose (see docker-compose.yaml ). Be sure that ports 27017 and 3000 are unused by other services npm run start:local runs a nodemon server that listens for changes in the src directory (requires nodemon and ts-node ) npm run start:prod starts the API server in the production env. Must be run after npm run build (requires node and tsc ) npm run test runs unit tests on new instances of MongoDB and the API (see docker-compose.test.yaml ). Once the tests finish running, both instances stop npm run test:local runs unit tests without docker and MongoDB (requires nyc , mocha , and ts-node ) npm run build builds the API for production and outputs the result in dist/ (requires tsc ) npm run lint lints the src directory according to tslint.json and tsconfig.json","title":"Available Commands"},{"location":"microservices/problems/","text":"Problems Among other functionality, WISP hosts an evolving set of problems and problem sets for users to attempt, and tracks their progress. The purpose of this microservice is to manage all data and logic relating to these problems and problem sets. API Documentation For a more extensive documentation, visit the swagger docs ProblemSets Model { title : String , description : String , tags : [ String ], problemCount : Number } GET /problemSets Query params includeProblems=true : for each problem set returned, includes an array of problems belonging to that problem set as the field problems Responses Status Response 200 Array of problemSets 500 Internal server error GET /problemSets/{problemSetId} Query params includeProblems=true : includes an array of problems belonging to the specified problem set as the field problems Params problemSetId : ID for problemSet to fetch Responses Status Response 200 ProblemSet 404 ProblemSet not found 422 Missing or invalid problemSetId 500 Internal server error POST /problemSets Body See ProblemSet model Responses Status Response 200 ProblemSet 422 Missing or invalid params in body 500 Internal server error PUT /problemSets/{problemSetId} Params problemSetId : ID for problemSet to update Body See ProblemSet model Responses Status Response 200 ProblemSet 404 ProblemSet not found 422 Missing or invalid problemSetId or body 500 Internal server error DELETE /problemSets/{problemSetId} Params problemSetId : ID for problemSet to delete Responses Status Response 200 Empty 404 ProblemSet not found 422 Missing or invalid problemSetId 500 Internal server error Problems Model { title : String , source : String , problemId : String , sourceLink : String , problemSetIds : [ String ], problemMetadata : { platformProblemId : String , difficulty : String } } NOTE: problemId is generated by the backend, and should not be included in POST/PUT requests GET /problems Responses Status Response 200 Array of problems 500 Internal server error GET /problems/{problemId} Params problemId : ID for problem to fetch Responses Status Response 200 Problem 404 Problem not found 422 Missing or invalid problemId 500 Internal server error POST /problems Body See Problem model, but don't include problemId parameter in the body Responses Status Response 200 Problem 422 Missing or invalid params in body 500 Internal server error PUT /problems/{problemId} Params problemId : ID for problem to update Body See Problem model, but don't include problemId parameter in the body Responses Status Response 200 Problem 404 Problem not found 422 Missing or invalid problemId or body 500 Internal server error DELETE /problems/{problemId} Params problemId : ID for problem to delete Responses Status Response 200 Empty 404 Problem not found 422 Missing or invalid problemId 500 Internal server error GET /problems/{problemId}/exists Params generatedProblemId : ID for problem to fetch This generatedProblemId that is used in this requests URL is a custom ID that can be generated by the hash of platform name and number. This is as an alternative to using the Mongo ID, as the microservice needs to check the existance of problems using minimal information, without knowing the MongoID. Example: in the case of Codeforces problem, the generatedProblemId is created by concatenating the platform (\"CODEFORCES\") and the problem ID as displayed on the platform (\"1352G\"), and then taking the SHA-1 hash of the resulting string. This is the problemId from the Problem model (instead of the usual mongo ID) Responses Status Response 200 Problem 404 Problem not found 422 Missing or invalid generatedProblemId 500 Internal server error","title":"Problems"},{"location":"microservices/problems/#problems","text":"Among other functionality, WISP hosts an evolving set of problems and problem sets for users to attempt, and tracks their progress. The purpose of this microservice is to manage all data and logic relating to these problems and problem sets.","title":"Problems"},{"location":"microservices/problems/#api-documentation","text":"For a more extensive documentation, visit the swagger docs","title":"API Documentation"},{"location":"microservices/problems/#problemsets","text":"Model { title : String , description : String , tags : [ String ], problemCount : Number } GET /problemSets Query params includeProblems=true : for each problem set returned, includes an array of problems belonging to that problem set as the field problems Responses Status Response 200 Array of problemSets 500 Internal server error GET /problemSets/{problemSetId} Query params includeProblems=true : includes an array of problems belonging to the specified problem set as the field problems Params problemSetId : ID for problemSet to fetch Responses Status Response 200 ProblemSet 404 ProblemSet not found 422 Missing or invalid problemSetId 500 Internal server error POST /problemSets Body See ProblemSet model Responses Status Response 200 ProblemSet 422 Missing or invalid params in body 500 Internal server error PUT /problemSets/{problemSetId} Params problemSetId : ID for problemSet to update Body See ProblemSet model Responses Status Response 200 ProblemSet 404 ProblemSet not found 422 Missing or invalid problemSetId or body 500 Internal server error DELETE /problemSets/{problemSetId} Params problemSetId : ID for problemSet to delete Responses Status Response 200 Empty 404 ProblemSet not found 422 Missing or invalid problemSetId 500 Internal server error","title":"ProblemSets"},{"location":"microservices/problems/#problems_1","text":"Model { title : String , source : String , problemId : String , sourceLink : String , problemSetIds : [ String ], problemMetadata : { platformProblemId : String , difficulty : String } } NOTE: problemId is generated by the backend, and should not be included in POST/PUT requests GET /problems Responses Status Response 200 Array of problems 500 Internal server error GET /problems/{problemId} Params problemId : ID for problem to fetch Responses Status Response 200 Problem 404 Problem not found 422 Missing or invalid problemId 500 Internal server error POST /problems Body See Problem model, but don't include problemId parameter in the body Responses Status Response 200 Problem 422 Missing or invalid params in body 500 Internal server error PUT /problems/{problemId} Params problemId : ID for problem to update Body See Problem model, but don't include problemId parameter in the body Responses Status Response 200 Problem 404 Problem not found 422 Missing or invalid problemId or body 500 Internal server error DELETE /problems/{problemId} Params problemId : ID for problem to delete Responses Status Response 200 Empty 404 Problem not found 422 Missing or invalid problemId 500 Internal server error GET /problems/{problemId}/exists Params generatedProblemId : ID for problem to fetch This generatedProblemId that is used in this requests URL is a custom ID that can be generated by the hash of platform name and number. This is as an alternative to using the Mongo ID, as the microservice needs to check the existance of problems using minimal information, without knowing the MongoID. Example: in the case of Codeforces problem, the generatedProblemId is created by concatenating the platform (\"CODEFORCES\") and the problem ID as displayed on the platform (\"1352G\"), and then taking the SHA-1 hash of the resulting string. This is the problemId from the Problem model (instead of the usual mongo ID) Responses Status Response 200 Problem 404 Problem not found 422 Missing or invalid generatedProblemId 500 Internal server error","title":"Problems"},{"location":"microservices/users/","text":"Users The purpose of this microservice is to manage all logic relating to users and to privide OAuth2.0-compliant authorization endpoints. Since WISP allows users to solve problems across multiple sites (such as Codeforces and Katis), it is this microservice's role to collect and keep the user's information in-sync across all sites. API Documentation For a more extensive documentation, visit the swagger docs Auth POST /auth/login Body { \"email\" : \"example@gmail.com\" , \"password\" : \"password\" } Responses Status Response 200 {\"token\": \"jwt token\", \"user\": {...}} 400 Invalid email or passowrd 422 Missing or invalid email/password 500 Internal server error POST /auth/introspect Params token : JWT token to introspect uri : uri used in the request method : HTTP method Responses Status Response 200 {\"active\": true, \"user\": {...}} 401 Unauthorized Users Model { username : String , email : String password : String , role : String , info : { major : String , year : String , school : String , bio : String , profilePhoto : String , }, problemSets : [ ObjectId ], problems : [ { problemId : String , isComplete : Boolean , status : String , }, ], platformData : { codeforces : { username : String , email : String , lastSubmission : { problemId : String , isComplete : Boolean , status : String , }, }, }, createdAt : Date , updatedAt : Date } GET /users Responses Status Response 200 Array of users 500 Internal server error GET /users/{userId} Params userId : ID for user to fetch Responses Status Response 200 User 404 User not found 422 Missing or invalid userId 500 Internal server error POST /users Body See user model Responses Status Response 200 User 400 User already exists 422 Missing or invalid params in body 500 Internal server error PUT /users/{userId} Params userId : ID for user to update Body See user model Responses Status Response 200 User 404 User not found 422 Missing or invalid userId or body 500 Internal server error DELETE /users/{userId} Params userId : ID for user to delete Responses Status Response 200 Empty 404 User not found 422 Missing or invalid userId 500 Internal server error PATCH /users/{userId}/problems Appends problem to the user's list of problems Params userId : ID for user to update Body { \"problemId\" : \"ObjectId\" } Responses Status Response 200 User 404 User not found 422 Missing or invalid userId/problemId in body 500 Internal server error PATCH /users/{userId}/problemSets Appends problemSet to the user's list of problemSets Params userId : ID for user to update Body { \"problemSetId\" : \"ObjectId\" } Responses Status Response 200 User 404 User not found 422 Missing or invalid userId/problemSetId in body 500 Internal server error PATCH /users/resetLastSubmissions Resets the codeforces lastSubmission field for all users Responses Status Response 200 Empty 500 Internal server error","title":"Users"},{"location":"microservices/users/#users","text":"The purpose of this microservice is to manage all logic relating to users and to privide OAuth2.0-compliant authorization endpoints. Since WISP allows users to solve problems across multiple sites (such as Codeforces and Katis), it is this microservice's role to collect and keep the user's information in-sync across all sites.","title":"Users"},{"location":"microservices/users/#api-documentation","text":"For a more extensive documentation, visit the swagger docs","title":"API Documentation"},{"location":"microservices/users/#auth","text":"POST /auth/login Body { \"email\" : \"example@gmail.com\" , \"password\" : \"password\" } Responses Status Response 200 {\"token\": \"jwt token\", \"user\": {...}} 400 Invalid email or passowrd 422 Missing or invalid email/password 500 Internal server error POST /auth/introspect Params token : JWT token to introspect uri : uri used in the request method : HTTP method Responses Status Response 200 {\"active\": true, \"user\": {...}} 401 Unauthorized","title":"Auth"},{"location":"microservices/users/#users_1","text":"Model { username : String , email : String password : String , role : String , info : { major : String , year : String , school : String , bio : String , profilePhoto : String , }, problemSets : [ ObjectId ], problems : [ { problemId : String , isComplete : Boolean , status : String , }, ], platformData : { codeforces : { username : String , email : String , lastSubmission : { problemId : String , isComplete : Boolean , status : String , }, }, }, createdAt : Date , updatedAt : Date } GET /users Responses Status Response 200 Array of users 500 Internal server error GET /users/{userId} Params userId : ID for user to fetch Responses Status Response 200 User 404 User not found 422 Missing or invalid userId 500 Internal server error POST /users Body See user model Responses Status Response 200 User 400 User already exists 422 Missing or invalid params in body 500 Internal server error PUT /users/{userId} Params userId : ID for user to update Body See user model Responses Status Response 200 User 404 User not found 422 Missing or invalid userId or body 500 Internal server error DELETE /users/{userId} Params userId : ID for user to delete Responses Status Response 200 Empty 404 User not found 422 Missing or invalid userId 500 Internal server error PATCH /users/{userId}/problems Appends problem to the user's list of problems Params userId : ID for user to update Body { \"problemId\" : \"ObjectId\" } Responses Status Response 200 User 404 User not found 422 Missing or invalid userId/problemId in body 500 Internal server error PATCH /users/{userId}/problemSets Appends problemSet to the user's list of problemSets Params userId : ID for user to update Body { \"problemSetId\" : \"ObjectId\" } Responses Status Response 200 User 404 User not found 422 Missing or invalid userId/problemSetId in body 500 Internal server error PATCH /users/resetLastSubmissions Resets the codeforces lastSubmission field for all users Responses Status Response 200 Empty 500 Internal server error","title":"Users"}]}